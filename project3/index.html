<!DOCTYPE html>
<html>

<head>
    <title>Project 3</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <h1>Project 3: Image Warping and Mosaicing</h1>

    <h2>Part A1: Shoot the Pictures</h2>
    <div class="desc">
        Three of these image pairs were taken in SF on a cloudy day with my digicam. The last was taken of a corner of my room on my phone (hi Laufey!!). 
    </div>
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/park_c.JPG">
        </div>
        <div class="image-container">
            <img src="part_a_ims/park_d.JPG">
        </div>

    </div>
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/roof_a.JPG">
        </div>
        <div class="image-container">
            <img src="part_a_ims/roof_b.JPG">
        </div>
    </div>
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/roof_1.JPG">
        </div>
        <div class="image-container">
            <img src="part_a_ims/roof_2.JPG">
        </div>
    </div>
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/room_2.jpg">
        </div>
        <div class="image-container">
            <img src="part_a_ims/room_3.jpg">
        </div>
    </div>

    <h2>Part A2: Recover Homographies</h2>

    I use the hints provided in lecture notes in order to set up the calculation of the homography matrix. As the discussion so eloquently explains, homographies are defined up to scale, so we can fix h9 = 1. With 8 unknowns (we fix i to be 1, as the scaling factor), we need at least 4 sets of points (each providing an x, y value) to completely solve the equation. However, it is helpful to have more than 4 sets of points, for greater accuracy, as overdetermining the system can help make up for correspondence errors. Then, we can use least squares to minimize the inaccuracies in the homography matrix. 


    I change the shape of H to make it easier to solve for a-h. Discussion 5 does a great way of explaining the process of solving and simplifying equations to get the resulting homography matrix.
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/sys_equations.png">
        </div>
        <div class="image-container">
            <img src="part_a_ims/h.png">
        </div>
    </div>

    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/part_2/park_c.png">
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_2/park_d.png">
        </div>
    </div>
    <div class="image-container">
            <img src="part_a_ims/part_2/park.png">
        </div>
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/part_2/roof_1.png">
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_2/roof_2.png">
        </div>
    </div>
    <div class="image-container">
            <img src="part_a_ims/part_2/roof_num.png">
        </div>
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/part_2/roof_a.png">
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_2/roof_b.png">
        </div>
    </div>
    <div class="image-container">
            <img src="part_a_ims/part_2/roof.png">
        </div>

    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/part_2/room_2.png">
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_2/room_3.png">
        </div>
    </div>
    <div class="image-container">
            <img src="part_a_ims/part_2/room.png">
        </div>
    <h2>Part A3: Warp the Images</h2>

    For both of these functions, I implement a helper function to get the bounds of the new image, after applying the homography matrix. To implement the nearest neighbor code, I use the inverse of the homography matrix to get the corresponding source pixel for each output pixel, rounding coordinates to the nearest pixel data. I make sure to normalize the result of the coordinates (as they are all multiplied by w), round to the nearest whole number index, and ensure the corresponding source pixel is within bounds of the original image. 

    We actually already had to implement bilinear interpolation during the first 189 homework (which caused me quite some grief) so I got to implement it again! We still get the coordinates in the source pixel that correspond with each output pixel, but instead, use the weighted averaging of the four neighboring pixels. It took some time for me to figure out the weights of each pixel (it can be somewhat counterintuitive) and construct the image based on these points and weights. 

    I also set the alpha mask for each image to be 1 where the image exists, and 0 in other places. This becomes helpful later in the project! Having a part of the image that doesn’t exist being interpreted as black vs. clear could definitely cause annoying issues. 

    To test out my functions, I perform rectification with images that have known squares. I select the four points of the square clockwise for im1points and map to [0,0],[100,0],[100,100],[0,100].

    These were both taken in the Netherlands!
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/part_3/roof.jpg">
            <div class="desc">original</div>
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_3/output_roof.png">
            <div class="desc">selected points</div>
        </div>
    <div class="image-row">
            <div class="image-container">
            <img src="part_a_ims/part_3/roof_warped.png">
            <div class="desc">nearest neighbor</div>
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_3/roof_warped_bi.png">
            <div class="desc">bilinear</div>
        </div>
        </div>
    <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/part_3/floor_cropped.jpg">
            <div class="desc">original</div>
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_3/output_floor.png">
            <div class="desc">selected points</div>
        </div>
    <div class="image-row">
            <div class="image-container">
            <img src="part_a_ims/part_3/floor_cropped_warped.png">
            <div class="desc">nearest neighbor</div>
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_3/floor_cropped_warped_bi.png">
            <div class="desc">bilinear</div>
        </div>
        </div>

        It takes about 20-25% more time to do bilinear interpolation vs nearest neighbor interpolation (2.22 vs 2.86 seconds for the window and 2.69 vs 3.00 seconds for the floor). This might be because we need to consider four points instead of one and thus more computations to weight each point. 

        In terms of quality, the bilinear interpolation takes the cake. The lines around the window are so much less grainy than nearest neighbor interpolation because it takes into account many pixels, instead of a lumpy look where edges that are black get somewhat warped. Some of the lines in the floor also have a jagged look for nearest neighbor interpolation, particularly with the dark brown in the upper right-hand corner. 

        <h2>Part A4: Blend the Images into a Mosaic</h2>

        First, to make sure that my image overlapping was working well, I implemented a naive algorithm that just weights images by 0.5 in the overlap region and 1 elsewhere. You can see that the edges of the images are very clear, so this was a sign to try something fancier. 
<div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/roof_1.JPG">
        </div>
        <div class="image-container">
            <img src="part_a_ims/roof_2.JPG">
</div>
 </div>
        <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/part_4/roof_2_overlapped.png">
        </div>
   

    For the Gaussian/Laplacian blending, I follow the steps outlined in the project description.
1. I calculate the dimensions of the output image
2. I pad both images with 0s to match the dimensions of the output image.
3. I use scipy.ndimage.distance_transform_edt to create a distance map for each image
4. I create the mask to blend with using these distance maps for each image, setting the mask to 1 where the distance map at the first image is greater than the distance map at the second image.
5. I blurred this mask with a Gaussian kernel
6. Utilizing my code from project 2, I create Gaussian and Laplacian stacks and put the blended images back together!

This image taken from Mission Dolores Park really bothers me. I tried using a larger Gaussian kernel (60 pixels) and 5 levels but the different in sky color is still quite apparent. I think the weather was so temperamental it changed in the second I moved my camera!
<div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/park_c.JPG">
        </div>
        <div class="image-container">
            <img src="part_a_ims/park_d.JPG">
        </div>
        </div>
        <div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/part_4/park_final_image.png">
        </div>
        </div>
It’s almost impossible to see the seam for this indoor image!
<div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/room_2.jpg">
        </div>
        <div class="image-container">
            <img src="part_a_ims/room_3.jpg">
        </div>
        
        <div class="image-container">
            <img src="part_a_ims/part_4/room_final_image.png">
        </div>
        </div>

This other outdoor image taken from the roof of an apartment building does quite well. 

<div class="image-row">
        <div class="image-container">
            <img src="part_a_ims/roof_a.JPG">
        </div>
        <div class="image-container">
            <img src="part_a_ims/roof_b.JPG">
        </div>
        </div>
        <div class="image-container">
            <img src="part_a_ims/part_4/roof_final_image.png">
        </div>
        

</html>